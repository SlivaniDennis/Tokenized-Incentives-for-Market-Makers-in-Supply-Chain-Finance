(define-constant ERR-NOT-AUTHORIZED u401)
(define-constant ERR-INSUFFICIENT-BALANCE u101)
(define-constant ERR-INVALID-AMOUNT u102)
(define-constant ERR-INVALID-POOL u103)
(define-constant ERR-POOL-ALREADY-EXISTS u104)
(define-constant ERR-POOL-NOT-FOUND u105)
(define-constant ERR-INVALID-TOKEN u106)
(define-constant ERR-SLIPPAGE u107)
(define-constant ERR-TRANSFER-FAILED u108)
(define-constant ERR-MATH-OVERFLOW u109)
(define-constant ERR-MATH-UNDERFLOW u110)
(define-constant ERR-INVALID-FEE u111)
(define-constant ERR-PAUSED u112)
(define-constant ERR-INVALID-LIQUIDITY u113)
(define-constant ERR-INVALID-SHARES u114)
(define-constant ERR-INVALID-RESERVES u115)
(define-constant ERR-INVALID-K u116)
(define-constant ERR-INVALID-PARAM u117)
(define-constant ERR-ALREADY-INITIALIZED u118)
(define-constant ERR-NOT-INITIALIZED u119)
(define-constant ERR-INVALID-RECIPIENT u120)
(define-constant ERR-INVALID-SENDER u121)
(define-constant ERR-INVALID-ORACLE u122)
(define-constant ERR-PRICE-ORACLE-FAIL u123)
(define-constant ERR-INVALID-TIMESTAMP u124)
(define-constant ERR-COOLDOWN-NOT-MET u125)
(define-constant ERR-INVALID-COOLDOWN u126)
(define-constant ERR-INVALID-DEADLINE u127)
(define-constant ERR-DEADLINE-PASSED u128)
(define-constant ERR-INVALID-MIN-OUT u129)
(define-constant ERR-INVALID-MAX-IN u130)
(define-constant ERR-INVALID-SWAP-PATH u131)
(define-constant ERR-ROUTER-NOT-SET u132)
(define-constant ERR-INVALID-ROUTER u133)
(define-constant ERR-FLASH-LOAN-FAILED u134)
(define-constant ERR-INVALID-LOAN-AMOUNT u135)
(define-constant ERR-LOAN-NOT-REPAID u136)
(define-constant ERR-INVALID-PREMIUM u137)
(define-constant ERR-PREMIUM-NOT-PAID u138)
(define-constant ERR-INVALID-CALLBACK u139)
(define-constant ERR-CALLBACK-FAILED u140)
(define-constant FEE-DENOMINATOR u10000)
(define-constant FEE-RATE u30)
(define-constant MIN-LIQUIDITY u1000)
(define-constant MAX-SLIPPAGE u500)
(define-constant COOLDOWN-PERIOD u144)
(define-constant ORACLE-UPDATE-INTERVAL u60)
(define-constant MAX-POOLS u100)
(define-constant PRECISION u100000000)
(define-data-var contract-owner principal tx-sender)
(define-data-var is-paused bool false)
(define-data-var total-pools uint u0)
(define-data-var oracle-price uint u1000000)
(define-data-var last-oracle-update uint u0)
(define-data-var router-contract (optional principal) none)
(define-map pools { token-a: principal, token-b: principal } { reserve-a: uint, reserve-b: uint, total-shares: uint, fee-rate: uint, is-active: bool, last-k: uint, cooldown-end: uint })
(define-map user-shares { pool-id: { token-a: principal, token-b: principal }, user: principal } uint)
(define-map user-cooldowns { user: principal, pool-id: { token-a: principal, token-b: principal } } uint)
(define-map flash-loan-data { borrower: principal } { amount: uint, token: principal, premium: uint })
(define-read-only (get-pool (token-a principal) (token-b principal))
  (map-get? pools { token-a: token-a, token-b: token-b }))
(define-read-only (get-user-shares (token-a principal) (token-b principal) (user principal))
  (map-get? user-shares { pool-id: { token-a: token-a, token-b: token-b }, user: user }))
(define-read-only (get-reserves (token-a principal) (token-b principal))
  (let ((pool (unwrap! (get-pool token-a token-b) (err ERR-POOL-NOT-FOUND))))
    (ok { reserve-a: (get reserve-a pool), reserve-b: (get reserve-b pool) })))
(define-read-only (get-total-shares (token-a principal) (token-b principal))
  (let ((pool (unwrap! (get-pool token-a token-b) (err ERR-POOL-NOT-FOUND))))
    (ok (get total-shares pool))))
(define-read-only (get-fee-rate (token-a principal) (token-b principal))
  (let ((pool (unwrap! (get-pool token-a token-b) (err ERR-POOL-NOT-FOUND))))
    (ok (get fee-rate pool))))
(define-read-only (get-oracle-price)
  (ok (var-get oracle-price)))
(define-read-only (is-contract-owner (caller principal))
  (is-eq caller (var-get contract-owner)))
(define-private (mul-down (a uint) (b uint))
  (/ (* a b) PRECISION))
(define-private (div-down (a uint) (b uint))
  (/ (* a PRECISION) b))
(define-private (calculate-k (reserve-a uint) (reserve-b uint))
  (* reserve-a reserve-b))
(define-private (check-slippage (amount-out uint) (min-out uint))
  (if (>= amount-out min-out)
    (ok true)
    (err ERR-SLIPPAGE)))
(define-private (transfer-token (token principal) (amount uint) (sender principal) (recipient principal))
  (contract-call? token ft-transfer amount sender recipient))
(define-private (update-reserves (token-a principal) (token-b principal) (new-reserve-a uint) (new-reserve-b uint) (new-k uint))
  (map-set pools { token-a: token-a, token-b: token-b } (merge (unwrap-panic (get-pool token-a token-b)) { reserve-a: new-reserve-a, reserve-b: new-reserve-b, last-k: new-k })))
(define-private (calculate-shares (amount-a uint) (amount-b uint) (reserve-a uint) (reserve-b uint) (total-shares uint))
  (if (is-eq total-shares u0)
    (sqrti (* amount-a amount-b))
    (min (div-down (* amount-a total-shares) reserve-a) (div-down (* amount-b total-shares) reserve-b))))
(define-private (calculate-amount-out (amount-in uint) (reserve-in uint) (reserve-out uint))
  (let ((amount-in-with-fee (* amount-in (- FEE-DENOMINATOR FEE-RATE))))
    (/ (* amount-in-with-fee reserve-out) (+ (* reserve-in FEE-DENOMINATOR) amount-in-with-fee))))
(define-private (validate-amount (amount uint))
  (if (> amount u0)
    (ok true)
    (err ERR-INVALID-AMOUNT)))
(define-private (validate-pool-exists (token-a principal) (token-b principal))
  (if (is-some (get-pool token-a token-b))
    (ok true)
    (err ERR-POOL-NOT-FOUND)))
(define-private (validate-pool-not-exists (token-a principal) (token-b principal))
  (if (is-none (get-pool token-a token-b))
    (ok true)
    (err ERR-POOL-ALREADY-EXISTS)))
(define-private (validate-not-paused)
  (if (not (var-get is-paused))
    (ok true)
    (err ERR-PAUSED)))
(define-private (validate-is-owner)
  (if (is-contract-owner tx-sender)
    (ok true)
    (err ERR-NOT-AUTHORIZED)))
(define-private (validate-cooldown (token-a principal) (token-b principal))
  (let ((cooldown (default-to u0 (map-get? user-cooldowns { user: tx-sender, pool-id: { token-a: token-a, token-b: token-b } }))))
    (if (>= block-height cooldown)
      (ok true)
      (err ERR-COOLDOWN-NOT-MET))))
(define-private (update-cooldown (token-a principal) (token-b principal))
  (map-set user-cooldowns { user: tx-sender, pool-id: { token-a: token-a, token-b: token-b } } (+ block-height COOLDOWN-PERIOD)))
(define-private (validate-deadline (deadline uint))
  (if (>= deadline block-height)
    (ok true)
    (err ERR-DEADLINE-PASSED)))
(define-public (create-pool (token-a principal) (token-b principal) (fee-rate uint))
  (begin
    (try! (validate-is-owner))
    (try! (validate-pool-not-exists token-a token-b))
    (asserts! (< (var-get total-pools) MAX-POOLS) (err ERR-INVALID-POOL))
    (asserts! (<= fee-rate FEE-RATE) (err ERR-INVALID-FEE))
    (asserts! (not (is-eq token-a token-b)) (err ERR-INVALID-TOKEN))
    (map-set pools { token-a: token-a, token-b: token-b } { reserve-a: u0, reserve-b: u0, total-shares: u0, fee-rate: fee-rate, is-active: true, last-k: u0, cooldown-end: u0 })
    (var-set total-pools (+ (var-get total-pools) u1))
    (print { event: "pool-created", token-a: token-a, token-b: token-b, fee-rate: fee-rate })
    (ok true)))
(define-public (add-liquidity (token-a principal) (token-b principal) (amount-a uint) (amount-b uint) (min-shares uint) (deadline uint))
  (let ((pool (unwrap! (get-pool token-a token-b) (err ERR-POOL-NOT-FOUND))) (reserve-a (get reserve-a pool)) (reserve-b (get reserve-b pool)) (total-shares (get total-shares pool)))
    (try! (validate-not-paused))
    (try! (validate-deadline deadline))
    (try! (validate-amount amount-a))
    (try! (validate-amount amount-b))
    (let ((shares (calculate-shares amount-a amount-b reserve-a reserve-b total-shares)))
      (asserts! (>= shares min-shares) (err ERR-SLIPPAGE))
      (try! (transfer-token token-a amount-a tx-sender (as-contract tx-sender)))
      (try! (transfer-token token-b amount-b tx-sender (as-contract tx-sender)))
      (let ((new-reserve-a (+ reserve-a amount-a)) (new-reserve-b (+ reserve-b amount-b)) (new-k (calculate-k new-reserve-a new-reserve-b)))
        (asserts! (>= new-k (get last-k pool)) (err ERR-INVALID-K))
        (update-reserves token-a token-b new-reserve-a new-reserve-b new-k)
        (map-set pools { token-a: token-a, token-b: token-b } (merge pool { total-shares: (+ total-shares shares) }))
        (map-set user-shares { pool-id: { token-a: token-a, token-b: token-b }, user: tx-sender } (+ (default-to u0 (get-user-shares token-a token-b tx-sender)) shares))
        (print { event: "liquidity-added", token-a: token-a, token-b: token-b, amount-a: amount-a, amount-b: amount-b, shares: shares })
        (ok shares)))))
(define-public (remove-liquidity (token-a principal) (token-b principal) (shares uint) (min-amount-a uint) (min-amount-b uint) (deadline uint))
  (let ((pool (unwrap! (get-pool token-a token-b) (err ERR-POOL-NOT-FOUND))) (reserve-a (get reserve-a pool)) (reserve-b (get reserve-b pool)) (total-shares (get total-shares pool)) (user-shares-amount (unwrap! (get-user-shares token-a token-b tx-sender) (err ERR-INSUFFICIENT-BALANCE))))
    (try! (validate-not-paused))
    (try! (validate-deadline deadline))
    (try! (validate-cooldown token-a token-b))
    (try! (validate-amount shares))
    (let ((amount-a (div-down (* shares reserve-a) total-shares)) (amount-b (div-down (* shares reserve-b) total-shares)))
      (asserts! (>= amount-a min-amount-a) (err ERR-SLIPPAGE))
      (asserts! (>= amount-b min-amount-b) (err ERR-SLIPPAGE))
      (let ((new-reserve-a (- reserve-a amount-a)) (new-reserve-b (- reserve-b amount-b)) (new-k (calculate-k new-reserve-a new-reserve-b)))
        (asserts! (>= new-k (get last-k pool)) (err ERR-INVALID-K))
        (update-reserves token-a token-b new-reserve-a new-reserve-b new-k)
        (map-set pools { token-a: token-a, token-b: token-b } (merge pool { total-shares: (- total-shares shares) }))
        (map-set user-shares { pool-id: { token-a: token-a, token-b: token-b }, user: tx-sender } (- user-shares-amount shares))
        (as-contract (try! (transfer-token token-a amount-a tx-sender tx-sender)))
        (as-contract (try! (transfer-token token-b amount-b tx-sender tx-sender)))
        (update-cooldown token-a token-b)
        (print { event: "liquidity-removed", token-a: token-a, token-b: token-b, shares: shares, amount-a: amount-a, amount-b: amount-b })
        (ok { amount-a: amount-a, amount-b: amount-b })))))
(define-public (swap (token-in principal) (token-out principal) (amount-in uint) (min-amount-out uint) (deadline uint))
  (let ((pool (unwrap! (get-pool token-in token-out) (err ERR-POOL-NOT-FOUND))) (reserve-in (get reserve-a pool)) (reserve-out (get reserve-b pool)))
    (try! (validate-not-paused))
    (try! (validate-deadline deadline))
    (try! (validate-amount amount-in))
    (let ((amount-out (calculate-amount-out amount-in reserve-in reserve-out)))
      (try! (check-slippage amount-out min-amount-out))
      (try! (transfer-token token-in amount-in tx-sender (as-contract tx-sender)))
      (let ((new-reserve-in (+ reserve-in amount-in)) (new-reserve-out (- reserve-out amount-out)) (new-k (calculate-k new-reserve-in new-reserve-out)))
        (asserts! (>= new-k (get last-k pool)) (err ERR-INVALID-K))
        (update-reserves token-in token-out new-reserve-in new-reserve-out new-k)
        (as-contract (try! (transfer-token token-out amount-out tx-sender tx-sender)))
        (print { event: "swap-executed", token-in: token-in, token-out: token-out, amount-in: amount-in, amount-out: amount-out })
        (ok amount-out)))))
(define-public (set-paused (paused bool))
  (begin
    (try! (validate-is-owner))
    (var-set is-paused paused)
    (ok true)))
(define-public (update-oracle-price (new-price uint))
  (begin
    (try! (validate-is-owner))
    (asserts! (>= block-height (+ (var-get last-oracle-update) ORACLE-UPDATE-INTERVAL)) (err ERR-INVALID-TIMESTAMP))
    (var-set oracle-price new-price)
    (var-set last-oracle-update block-height)
    (ok true)))
(define-public (set-router (router principal))
  (begin
    (try! (validate-is-owner))
    (var-set router-contract (some router))
    (ok true)))
(define-public (flash-loan (token principal) (amount uint) (callback principal))
  (let ((pool (unwrap! (get-pool token (as-contract tx-sender)) (err ERR-POOL-NOT-FOUND))) (reserve (get reserve-a pool)))
    (try! (validate-not-paused))
    (asserts! (>= reserve amount) (err ERR-INSUFFICIENT-BALANCE))
    (let ((premium (/ (* amount FEE-RATE) FEE-DENOMINATOR)))
      (map-set flash-loan-data { borrower: tx-sender } { amount: amount, token: token, premium: premium })
      (as-contract (try! (transfer-token token amount tx-sender tx-sender)))
      (try! (contract-call? callback receive-flash-loan token amount))
      (let ((loan-data (unwrap! (map-get? flash-loan-data { borrower: tx-sender }) (err ERR-LOAN-NOT-REPAID))))
        (asserts! (is-eq (get amount loan-data) amount) (err ERR-INVALID-LOAN-AMOUNT))
        (asserts! (is-eq (get token loan-data) token) (err ERR-INVALID-TOKEN))
        (try! (transfer-token token (+ amount premium) tx-sender (as-contract tx-sender)))
        (map-delete flash-loan-data { borrower: tx-sender })
        (print { event: "flash-loan", borrower: tx-sender, amount: amount, premium: premium })
        (ok true)))))
(define-public (repay-flash-loan (token principal) (amount uint) (premium uint))
  (let ((loan-data (unwrap! (map-get? flash-loan-data { borrower: tx-sender }) (err ERR-LOAN-NOT-REPAID))))
    (asserts! (is-eq (get amount loan-data) amount) (err ERR-INVALID-LOAN-AMOUNT))
    (asserts! (is-eq (get premium loan-data) premium) (err ERR-INVALID-PREMIUM))
    (asserts! (is-eq (get token loan-data) token) (err ERR-INVALID-TOKEN))
    (try! (transfer-token token (+ amount premium) tx-sender (as-contract tx-sender)))
    (map-delete flash-loan-data { borrower: tx-sender })
    (ok true)))